#pragma once

#include <memory>
#include <sstream>
#include <unordered_map>
#include <stack>
#include <vector>
#include <iomanip>
#include <chrono>
#include <ctime>

#include "ast_builder.h"
#include "print_node.h"
#include "function_entry_node.h"
#include "variable_node.h"
#include "branch_node.h"
#include "operator_node.h"

class AssemblyGenerator {
public:
    struct GeneratorContext {
        std::string timestamp;
        std::string username;
        bool debugOutput;
        bool optimizeCode;
        int stackSize;

        GeneratorContext(const std::string& ts = "2025-04-08 12:09:01",
                        const std::string& user = "arabine",
                        bool debug = true,
                        bool optimize = true,
                        int stack = 1024)
            : timestamp(ts)
            , username(user)
            , debugOutput(debug)
            , optimizeCode(optimize)
            , stackSize(stack)
        {}
    };

    AssemblyGenerator(const GeneratorContext& context = GeneratorContext())
        : m_context(context)
    {
        Reset();
    }

    void Reset() {
        m_assembly.str("");
        m_labelCounter = 0;
        m_variableAddresses.clear();
        m_currentStackOffset = 0;
        m_stringLiterals.clear();
        m_depth = 0;
        m_currentSection = Section::NONE;
    }

    std::string GenerateAssembly(const std::vector<PathTree>& roots) {
        Reset();
        
        // Generate header comments
        GenerateHeader();

        // Generate data section
        StartSection(Section::DATA);
        GenerateDataSection(roots);

        // Generate bss section for uninitialized data
        StartSection(Section::BSS);
        GenerateBssSection();

        // Generate text section
        StartSection(Section::TEXT);
        GenerateTextSection(roots);

        return m_assembly.str();
    }

protected:
    enum class Section {
        NONE,
        DATA,
        BSS,
        TEXT
    };

    virtual void GenerateNodeCode(std::shared_ptr<ASTNode> node, bool isDataPath = false) {
        if (!node) return;

        if (m_context.debugOutput) {
            AddComment("Node: " + node->node->GetTypeName() + " (ID: " + node->node->GetId() + ")");
        }

        if (node->IsType<FunctionEntryNode>()) {
            GenerateFunctionEntry(node);
        }
        else if (node->IsType<BranchNode>()) {
            GenerateBranchNode(node);
        }
        else if (node->IsType<PrintNode>()) {
            GeneratePrintNode(node);
        }
        else if (node->IsType<OperatorNode>()) {
            GenerateOperatorNode(node);
        }
        else if (node->IsType<VariableNode>()) {
            GenerateVariableNode(node);
        }

        // If we're processing a data path, traverse data outputs
        if (isDataPath) {
            for (const auto& [port, outputs] : node->dataOutputs) {
                for (const auto& target : outputs) {
                    GenerateNodeCode(target.node, true);
                }
            }
        }
    }

private:
    GeneratorContext m_context;
    std::stringstream m_assembly;
    int m_labelCounter;
    std::unordered_map<std::string, std::string> m_variableAddresses;
    int m_currentStackOffset;
    std::vector<std::string> m_stringLiterals;
    int m_depth;
    Section m_currentSection;

    void GenerateHeader() {
        m_assembly << "; Assembly generated by Visual Node Editor\n"
                  << "; Generation time: " << m_context.timestamp << "\n"
                  << "; Generated by: " << m_context.username << "\n"
                  << "; Optimization: " << (m_context.optimizeCode ? "enabled" : "disabled") << "\n"
                  << "\n";
    }

    void StartSection(Section section) {
        if (m_currentSection == section) return;

        m_currentSection = section;
        switch (section) {
            case Section::DATA:
                m_assembly << "section .data\n";
                break;
            case Section::BSS:
                m_assembly << "section .bss\n";
                break;
            case Section::TEXT:
                m_assembly << "section .text\n"
                          << "global _start\n\n";
                break;
            default:
                break;
        }
    }

    void GenerateDataSection(const std::vector<PathTree>& trees) {
        // Generate string literals
        for (const auto& literal : m_stringLiterals) {
            std::string label = "str_" + std::to_string(m_labelCounter++);
            m_assembly << label << " db '" << literal << "',0\n"
                      << label << "_len equ $ - " << label << "\n";
        }

        // Generate variables
        for (const auto& t : trees) {
            CollectVariables(t.root);
        }
    }

    void GenerateBssSection() {
        m_assembly << "    stack_space resb " << m_context.stackSize << "\n";
    }

    void GenerateTextSection(const std::vector<PathTree>& trees) {
        // Program entry point
        m_assembly << "_start:\n";
        
        // Setup stack frame
        m_assembly << "    mov ebp, esp\n"
                  << "    sub esp, " << m_context.stackSize << "\n\n";

        // Process execution paths first
        for (const auto& tree : trees) {
            if (tree.isExecutionPath) {
                GenerateNodeCode(tree.root);
            }
        }

        // Process data paths
        for (const auto& tree : trees) {
            if (!tree.isExecutionPath) {
                GenerateNodeCode(tree.root, true);
            }
        }

        // Program exit
        GenerateExit();
    }

    void GenerateFunctionEntry(std::shared_ptr<ASTNode> node) {
        AddComment("Function Entry");
        m_depth++;
        
        for (auto& child : node->children) {
            GenerateNodeCode(child);
        }
        
        m_depth--;
    }

    void GenerateBranchNode(std::shared_ptr<ASTNode> node) {
        std::string labelTrue = GenerateUniqueLabel("true");
        std::string labelFalse = GenerateUniqueLabel("false");
        std::string labelEnd = GenerateUniqueLabel("end");

        AddComment("Branch condition evaluation");
        m_depth++;

        // Generate condition code
        if (auto conditionNode = node->GetDataInput(0)) {
            GenerateNodeCode(conditionNode);
        }

        // Compare result and jump
        m_assembly << "    pop eax\n"
                  << "    cmp eax, 0\n"
                  << "    je " << labelFalse << "\n";

        // True branch
        m_assembly << labelTrue << ":\n";
        if (node->GetChildCount() > 0) {
            GenerateNodeCode(node->GetChild(0));
        }
        m_assembly << "    jmp " << labelEnd << "\n";

        // False branch
        m_assembly << labelFalse << ":\n";
        if (node->GetChildCount() > 1) {
            GenerateNodeCode(node->GetChild(1));
        }

        m_assembly << labelEnd << ":\n";
        m_depth--;
    }

    void GeneratePrintNode(std::shared_ptr<ASTNode> node) {
        auto* printNode = node->GetAs<PrintNode>();
        if (!printNode) return;

        std::string text = printNode->GetText();
        std::string label = AddStringLiteral(text);

        // System call to write
        m_assembly << "    mov edx, " << label << "_len\n"
                  << "    mov ecx, " << label << "\n"
                  << "    mov ebx, 1\n"    // stdout
                  << "    mov eax, 4\n"    // sys_write
                  << "    int 0x80\n";
    }

    void GenerateOperatorNode(std::shared_ptr<ASTNode> node) {
        auto* opNode = node->GetAs<OperatorNode>();
        if (!opNode) return;

        AddComment("Operator: " + std::to_string(static_cast<int>(opNode->GetOperationType())));
        m_depth++;

        // Generate code for operands
        for (const auto& [port, inputNode] : node->dataInputs) {
            GenerateNodeCode(inputNode);
        }

        // Generate operator code
        switch (opNode->GetOperationType()) {
            case OperatorNode::OperationType::ADD:
                m_assembly << "    pop ebx\n"
                          << "    pop eax\n"
                          << "    add eax, ebx\n"
                          << "    push eax\n";
                break;
            case OperatorNode::OperationType::SUBTRACT:
                m_assembly << "    pop ebx\n"
                          << "    pop eax\n"
                          << "    sub eax, ebx\n"
                          << "    push eax\n";
                break;
            case OperatorNode::OperationType::MULTIPLY:
                m_assembly << "    pop ebx\n"
                          << "    pop eax\n"
                          << "    imul eax, ebx\n"
                          << "    push eax\n";
                break;
            case OperatorNode::OperationType::DIVIDE:
                m_assembly << "    pop ebx\n"
                          << "    pop eax\n"
                          << "    cdq\n"
                          << "    idiv ebx\n"
                          << "    push eax\n";
                break;
            // Add other operators...
        }

        m_depth--;
    }

    void GenerateVariableNode(std::shared_ptr<ASTNode> node) {
        auto* varNode = node->GetAs<VariableNode>();
        if (!varNode) return;

        std::string varName = varNode->GetVariableName();
        
        AddComment("Load variable: " + varName);
        m_assembly << "    mov eax, [" << m_variableAddresses[varName] << "]\n"
                  << "    push eax\n";
    }

    void GenerateExit() {
        AddComment("Program exit");
        m_assembly << "    mov eax, 1\n"    // sys_exit
                  << "    mov ebx, 0\n"    // return 0
                  << "    int 0x80\n";
    }

    void CollectVariables(std::shared_ptr<ASTNode> node) {
        if (!node) return;

        if (node->IsType<VariableNode>()) {
            auto* varNode = node->GetAs<VariableNode>();
            std::string varName = varNode->GetVariableName();
            if (m_variableAddresses.find(varName) == m_variableAddresses.end()) {
                m_variableAddresses[varName] = varName;
                m_assembly << varName << ":\n" << varNode->GenerateAssembly();
            }
        }

        // Traverse children
        for (auto& child : node->children) {
            CollectVariables(child);
        }

        // Traverse data inputs
        for (const auto& [port, inputNode] : node->dataInputs) {
            CollectVariables(inputNode);
        }
    }

    std::string AddStringLiteral(const std::string& text) {
        std::string label = "str_" + std::to_string(m_stringLiterals.size());
        m_stringLiterals.push_back(text);
        return label;
    }

    std::string GenerateUniqueLabel(const std::string& prefix) {
        return prefix + "_" + std::to_string(m_labelCounter++);
    }

    void AddComment(const std::string& comment) {
        if (m_context.debugOutput) {
            m_assembly << std::string(m_depth * 4, ' ') << "; " << comment << "\n";
        }
    }
};